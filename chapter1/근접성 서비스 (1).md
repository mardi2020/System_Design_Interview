## 근접성 서비스 설계

> 음식점, 호텔, 극장, 박물관 등 현재 위치에서 가까운 시설을 찾는데 이용 ex) Yelp 앱

### 기능 요구사항
1. 사용자의 위치(경도, 위도)와 검색 반경 정보에 매치되는 사업장 목록 반환
2. 사업장 소유주가 사업장 정보를 추가/삭제/갱신할 수 있도록 하되, 그 정보가 검색 결과에 실시간으로 반영될 필요는 없음
3. 고객은 사업장의 상세 정보를 살필 수 있어야 함

### 비기능 요구사항
1. 낮은 레이턴시: 사용자는 주변 사업장을 신속히 검색
2. 데이터 보호: 사용자 위치 정보는 민감한 정보로 GDPR, CCPA 등 데이터 사생활 보호 법안 준수
3. 고가용성 및 규모 확장성: 인구 밀집 지역에서 이용자가 집중되는 시간에 트래픽이 급증해도 감당할 수 있도록 시스템 설계

---

### API 설계 - REST API
- `GET` /v1/search/nearby : 특정 검색 기준에 맞는 사업장 목록 반환, 페이지네이션 생각하면 좋음
  - 넘겨질 파라미터: latitude(위도), longitude(경도), radius(default=5000m)
``` json
{
  "total": 10,
  "business": [{ "business object" }]
}
```
- `GET` /v1/businesses/:id : 특정 사업장의 상세 정보 반환
- `POST` /v1/businesses/ : 새로운 사업장 추가
- `PUT` /v1/businesses/:id : 사업장 상세 정보 갱신
- `DELETE` /v1/businesses/:id : 특정 사업장 정보 삭제

### 데이터 모델
- 읽기 비율
  - 주변 사업장 검색과 사업장 정보 확인의 기능이 자주 수행됨
- 쓰기 비율
  - 사업장 정보를 추가하거나 삭제, 편집하는 행위가 빈번하지 않음
 
읽기 연산이 압도적인 시스템에는 MySQL와 같은 관계형 데이터베이스가 바람직할 수 있다. 

### 데이터 스키마
- business table: 사업장 정보
  - business_id(PK), address, city, state, country, latitude, longitude
- geospatial index table: 지리적 위치 색인 테이블
  - 위치 정보 관련 연산의 효율성을 높이는데 쓰임
  - geohash 이해도 필요

### 개략적 설계 다이어그램
<img src="https://github.com/mardi2020/System_Design_Interview/assets/58351498/3555f799-8ad5-4b66-b45f-029c6f108e5a" width="600" height="700">

- 로드밸런서(LB): 유입 트래픽을 자동으로 여러 서비스에 분산시키는 컴포넌트, 단일 DNS entry point를 지정하고 URL 경로를 분석하여 어느 서비스에 트래픽을 전달할지 결정
- 위치 기반 서비스: 주어진 위치와 반경 정보를 이용해 주변 사업장 검색, 쓰기 요청이 없고 읽기 요청만 빈번한 서비스, 특정 시간대의 인구 밀집 지역일수록 QPS가 높음, 무상태 서비스
- 사업장 서비스: 기본적으로 쓰기 요청이면서 QPS가 높지 않지만 고객이 특정 시간대에 사업장을 조회할 때 QPS가 높아짐
- 데이터베이스 클러스터: 주-부 데이터베이스 형태, 실시간 반영이 필요없으므로 복제되는 시간에서의 차이는 고려하지 않아도 됨
  - 주 데이터베이스: 쓰기 요청
  - 부 데이터베이스: 읽기 요청
 
사업장 서비스와 위치 기반 서비스는 무상태 서비스이므로 사람이 몰리는 특정 시간대에 자동으로 서버를 추가해 대응하고, 사람이 없는 시간대에는 서버를 삭제하여 구동하도록 구현함

### 주변 사업장 검색 알고리즘
- Geohash in Redis, PostGIS 확장을 설치한 Postgres DB 주로 사용

#### 방안1) 2차원 검색
> 주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법

- 테이블 전체를 읽는 비효율적 SQL 코드
``` mysql
SELECT business_id, latitude, longitude
FROM business
WHERE latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius
  AND
    longitude BETWEEN {my_long} - radius AND {:my_long} + radius
```
위도와 경도를 칼럼에 인덱스를 건다고 해도 효율이 나아지지 않음, 데이터가 2차원적이므로 칼럼별로 가져온 결과도 엄청난 양임.
인덱스로는 오직 한차원의 검색 속도만 개선할 수 있다는 점도...

- 지리적 정보에 인덱스를 만드는 법: 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 인덱스를 만드는 법
  - 해시 기반 방안: even grid, `geohash`, cartesian tiers
  - 트리 기반 방안: `quadtree`, `google S2`, R-tree

#### 방안2) 균등 격자: 작은 격자 또는 구획으로 나누는 단순한 접근법
사업장 분포가 균등하지 않다는 문제점 -> 전 세계 모든 부분을 균등하게 나누면 데이터 분포는 균등하지 않음 (사막과 도시 한복판의 차이)

또 주어진 격자의 인접 격자를 찾기가 까다로을 수 있다는 점(격자 식별자 할당에 명확한 체계가 없음)

#### 방안3) Geohash: 2차원의 위도 경도 데이터를 1차원의 문자열로 반환, 비트를 하나씩 늘려가면서 재귀적으로 세계를 더 작은 격자로 분할해 나감
  - 각 사분면에 비트 할당(00, 01, 10, 11...)을 원하는 정밀도를 얻을 때까지 반복
  - 통상적으로 base32 표현법으로 표기함 ex) 1001 11010 01001 10001 11111 11110 -> 9q9hvu
  - 최적 정밀도: 지정한 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이를 구해야 함.
  - But, 격자 가장자리 처리 방식에 대한 edge case들은 면접관과 따로 이야기해 볼 것
   - 문제1) 해시값의 공통 접두어가 긴 격자들이 서로 더 가깝게 놓이도록 보장함, BUT 그 역은 참이 아님 => 따라서 단순하게 접두어 기반으로 질의문을 생성하더라도 주변의 모든 사업장을 가져올 수 없음
   - 문제2) 두 지점이 공통 접두어 길이는 길지만 서로 다른 격자에 놓이는 경우 => 현재 격자를 비롯한 인접한 모든 격자의 모든 사업장 정보를 가져오는것, 특정 지오해시의 주변 지오해시를 찾는 것은 상수 시간안에 찾을 수 있는 연산.
